### 置換に基づく高階型システム

[元講座動画 [6'52"]](http://youtu.be/7P2QtR9jM2o)


今回は、高階言語向けの置換に基づく型システムを定義します。第一章のLAMBDAを言語を使うので、レッスン1_8からの定義をコピペして下さい。

型確認装置を作っているので、手に入れたい機能はプログラムの宣言されている変数に型を添付することですね。変数を宣言出来る言語構造は `lambda`, `let`, `letrect`,と`mu`ですので、変更をそこから始めましょう。

今回、プログラムの実行向けの意味論を書いてないので、`Val`という構文カテゴリを削除できます。「値」を表す物はまだ必要ですが、それは`KResult`の役ですね。型確認装置なら、プログラムは型まで評価するので、型を結果にしたいんですね。

「型」を表すための`Type`ソートを宣言しましょう。許されるコンストラクションは`int`, `bool`、関数型(`type "->" `type`のやつ)です。丸括弧内の構造も追加したいので、`bracket`を用いる独自のやつを加えます。`lambda`関数の構造もちょっと調整することが必要です。今回、`lambda`が束縛する変数は型を表す注記が必要だからです。

終わったら、型を判断するルール(typing rules・typing judgments)を定義しましょう。`lambda X : T . E`は`T -> T'`まで評価します。`T'`は`E[T/X]`項の型判断の続きを表す抽象化です。望みの行動をエレガントに手に入れるため、ラムダ関数を`T -> E[T/X]`まで評価します。この意味論を使える前に、ラムダ関数を`Exp`引数まで拡張して正格的な物にする必要があります。

「適用」の型判断規則はかなり簡単です : `(T1->T2) T1 => T2`.

数学計算表現、真偽値表現の規則に進んでいきましょう。`Val`カテゴリはもう要らないんですが、IMP++の型確認装置と同様に、値まで縮小された項を適当な型で書き換える規則が必要です。それで、残っている意味論規則を型規則に変更して下さい。例えば `I1:Int + I2:Int => I1 +Int I2`を`int + int => int`と交換することです。最後に、`Type`を`Exp`のサブソートにすることが必要です。やらないとパーサーが効きません。

条件式の型を付ける手段は:

1. 第一引数が`bool`に評価されるべき
2. 第二引数と第三引数は両方`T`型に評価されるべき
3. 条件式の型は全体OKなら、その文が全体単一の`T`型の物に評価されます。

この行動を実装するため、条件式構造を全引数対`strict`にして、思う通りにの規則を書きます: `if bool then T:Type else T => T`。今回、第二・第三引数がちゃんと確認されることをランタイムでチェックしたいので、`:Type`の部分を明示的に含みます。

`let`構造なら、束縛する項の型注記を持たせていくだけでいいんです。`let`の規則は`macro`としてあるので、評価は構文糖衣を抜くことだけです。

`letrec`と`mu`は束縛している変数の型を表す注記が必要になったので、それらを変更していきましょう。`letrec`は今回も`mu`になる規則だけで表せますので、型をちゃんと宣言すればいいんです。

`mu`の型を付ける手段は、体が変数の`T`型になるはずで、その`T`型は`mu`表現全体の型にもなります。このパターンは以下のように表せます。

```
 rule mu X : T . E => (T -> T) (E[T/X])
```

関数適用は正格評価を用いるので、`E[T/X]`はいずれか対応する型になって、関数適用の規則と従って、最後に作り出されたのは`T`型になるはずです。


`kompile`して、`krun`でプログラムを実行してみて下さい。例えば第一章のLAMBDAプログラムをコピペして、型の注記を入れていけばいい。`krun`はそれらのプログラム対の型確認をします。

次回、型確認作業を他の立場から見るためにLAMBDA対の環境に基づく型確認装置を作ります。

