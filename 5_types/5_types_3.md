# 環境に基づく高階型システム

今回は、高階言語向けの環境に基づく型システムを定義します。このレッスンも第一章のラムダ言語から始まるので、前回の`.k`ファイルをコピペして下さい。実をいうと、置換を用いるルールしだけ変更するつもりなので、前回の定義の過半を問題なく再利用できます。タイトルの通り、置換はもう要らないので、`require "substitution.k"`と`imports SUBSTITUTION`も削除出来ます。表現や型の構文が変わりませんが、ラムダの[binder]タグも削除できます。

第一レッスンと同様に`<k/>`セル以上、型環境を持つための`<tenv/>`セルも保持するコンフィギュレーションが必要です。出来たら規則を定義する仕事に進んでいきましょう。

変数を検索する作業なら、環境に基づく定義は置換のと違って環境で検索する必要があります。検索する手順は以下の規則で表現できます：

```
    rule <k> X:Id => T ...</k> 
    <tenv>... X |-> T ...</k>
```

型の環境を表す`<tenv/>`セルにある要素はラムダの意味論規則に入れられるんです。

```
    rule <k> lambda X : T . E => (T -> E) ~> Rho ...</k>
         <tenv> Rho => Rho[X <- T] </tenv>
```

型環境の中に、`X`は対応するT型に束縛されて、`T -> E`は計算セルのキューにおいて置かれます。関数を表す矢印の型は正確的に評価される構造に変更したので、`E`はやがて対応する型まで縮小されるはずです。他の環境に基づく定義と同様に、計算が終わったら元の環境を復旧することが必要です。

関数適用の型を付ける手段は変わりません。

```
rule (T1 -> T2) T1 => T2
```

数学表現、真偽値表現、条件式表現、`let`表現、`letrec`表現もそのままでいいんです。

元の`mu`規則は置換で定義されたので、変更する必要があります。新たに作ったラムダと同じく変更すればいいんです。つまり、`X`を対する型に束縛して、残っている表現の体を型付けのキューに置いて、最後に型の環境を復旧する。

```
  rule <k> mu X : T . E => (T -> T) E ~> Rho ...</k>
       <tenv> Rho => Rho[X <- T] </tenv>
```

最後に、環境復旧をする規則を定義します。前の計算が型に評価されるまで復旧しないようにすることが必須です。

```
rule _:Type ~> (Rho => .) ... _ => Rho
```

置換に基づく定義と新たに作った定義を比べたら、変更したところはかなり直感的になりますね。もとの定義に置換が召喚された所を環境とのやりとりと交換しただけですね。

次のレッスンで、型推論装置をkでどのように定義できるってことを見ていきます。


