# 命令型環境に基づく型システム

[元講座動画 [10'11"]](http://youtu.be/WyUxdo7GhtE)


このレッスンで、「型環境」をもととするスタイルを使って、第四章のIMP++のような命令形プログラミング言語と合わせる型システムを定義する方法を見ていきます。

IMP++の意味論を持つ第四章レッスン7からの`imp.k`ファイルをコピペして、型システムに変更しましょう。出来上がったシステムを実行すれば、型確認装置になります。


最初に、IMP++の構文の正格アトリビュートを新たに定義します。今回の定義はプログラムにある項を型まで縮小するので、「Result・値」となることは`Type`です。`strict`というアトリビュートのほうが`seqstrict`より自由を許すので必要がなくなったタグを除きながら`seqstrict`を可能なところに`strict`にしていきます。ちょっと意外かもしれませんが、`spawn`も正格にしないとなりません。子供スレッドのコードは親スレッドの環境に型確認を成功することが必要だからです(これはいつもそうではなく、違うように実装されるスレッドシステムを含む言語が見たければ、tutorial/2_languages/1_simpleに定義される言語をご覧になって下さい。)。

型システムの立場から、`&&` 構造は両側の引数に正格評価を使うことが必要です。値を評価するための短絡意味論は型対無関係です。同様に、条件式の if 文も while ループも全引数に`strict`にしないといけません。

最後に、`Stmt`の合成適用を表す構造の引数が全部左から右へ正確的に評価されないとならないので`seqstrict`にします。なぜならば、右側にある二番目の引数が何かの代入文と仮定してご覧下さい。その文は型の環境を変えられますね。

それで、本物の型を定義する所に来ました。実は、型確認装置の文脈で、「型」を定義することは「計算の結果」を定義する事と同じです。今回の簡単である命令形プログラミング言語なら、いくつかの定数型だけ持っています： `int`, `bool`, `string`, `block`, `stmt`があります。

型確認装置の`configuration`も定義しましょう。`<k/>`セル以上、「型の環境(type environment)」を表す`<tenv/>`セルも加えます。この環境はプログラムの識別子から型までのマッピングを保存します。それに伴って、型の環境は「型の抽象領域に存在している状態」というようにも考えられます。

既にある値対定義されている意味論を型システム向けのものまで変化していきましょう。この意味論で手に入れたい機能は：

1. 言語の基本値を適当な型まで縮小すること
2. 言語に定義される構造が型まで縮小された項を引数として受けている時、その構造を適当な型まで縮小すること

何も忘れないため、上から始めて下まで進んでいきます。

整数と文字列はそれぞれ`int`, `string`型まで縮小します。

変数は型の環境を表す`<tenv/>`に検索されるだけです。IMP++の変数は整数以上のソート対束縛出来ないので、`tenv`にある物は`int`だけですけど、後でなにかの型宣言を加えたいようになったらなにも変える必要が出ないため、この規則を汎用的に書いていきます。与えられた意味論なら、宣言されていない変数を検索してみるプログラムは却下されて、この定義が暗黙的に使用する「却下」の解釈は*書き換えることが詰まっていて、進めないようになってしまいました*って言うことです。

変数を増やす`++X`は変数が`int`だから、そっちこそ`int`になります。

標準入力の内容を読んでくれる`read`は今回正数しか読めないので、結局`int`になります。

除算も`int`になる引数しか受けないので、`int`になりますが、除算をよく見たら、`/`記号は`AExp`対定義されているので、`int / int`のような計算がパーサーに却下されないため、`int`をAExpの構文につかすることが必要となります。「型」の項をどこにも問題なく書けるようになりたいんですね。そのため、`Type`を他の全ソートのsubtermとして書いていきます(つまり、AExpなどのソート定義の右側にTypeを加えます)。

足し算は正数と文字列でオーバロードされているので、型を付ける規則を２つ書いていかないとね。

`spawn`は、引数としてあるコードが`block`まで縮小された後、`stmt`になります。

変数代入を処理する構造は`strict(2)`で定義されるので、型を付けるポリシーは簡単に「束縛している識別子は右側の項と同じ型の物として考えて」ということです。今回も可能な限り汎用的に定義します。

真偽値の規則はかなり明示的と思います。

少しだですが、ブロックの規則はより複雑です。最初の気をつけていかなければならない部分は、ブロックレベルの変数は外の範囲に見えない特徴を守るため、ブロックに型が付いた後、環境を今回も復旧作業が必要です。ブロック内の文が型になるまで、環境を復旧しません。型まで評価されたら、環境を復旧する時点で、`block`型のアイテムとして書き換えます。

ブロック中のコードはそっちこそブロックとしてある可能性もちゃんと処理しないとね(例えば `{ {S} }`)。独自の規則を作ることの代わりに、`block`と`stmt`型を新たな`BlockOrStmtType`型に組み合わせることで一石二鳥になります。`Type`の元定義にも`block`と`stmt`を`BlockOrStmtType`サブソートにしていきます。

IMP++で、`int`になる数学的な表現を文のなかに許すので、表現・expressionの文は思い通りに型まで評価します。

条件式の型を付ける手段は:

1. 最初の引数が`bool`になる
2. 枝にある文は双方`block`に評価されたら、条件式全体が`stmt`型になります。
   
`while`文は、左にあるの引数が`bool`になって右にあるのは`block`になるはずです。

変数宣言は新しい束縛を型の環境に加えるので、対応する規則は`<tenv/>`セルを変える機能が必須です。

`print`文は２つのソート(整数も文字列も)対定義されていますね。ブロックの型付け手段の時にこのような問題を解決しましたね。それと同様に、`int`と`string`のケースを２つの独自な規則として作る必要がなくなるため、`PrintableType`という`int`も`string`も含む特別なカテゴリを作っていきます。

`halt`は`stmt`になって、`join`の引数が`int`になったら結局的に`stmt`になります。

順編合成は空白で区別されている`seqstrict`リストとして宣言しました。型を付ける手段は「リストが`stmt`になれるために、リストの中にある要素が全部`stmt`か`block`まで評価されるべき」ということです。
リストは普通の cons/nil 構成で実装されるので、型付与手段を実装するのは簡単に以下のように出来ます：

```
    rule .Stmts => stmt
    rule _:BlockOrStmtType Ss => Ss
```

空の連続を`stmt`まで評価する最初の規則は空のブロック`{}`を評価するためにも用いられます。

出来たら、`imp.k`を`kompile`して、第四章のプログラムを実行してみて下さい。それらのプログラムは全て`stmt`型まで評価されるはずです。

次のレッスンで、LAMBDA向けの置換に基づく型システムを定義する方法を調べていきます。
