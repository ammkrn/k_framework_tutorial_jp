# 由来される構造、あらかじめ作成された構文を拡張すること

[元講座動画 [5'10"]](http://youtu.be/qZWiBaN7zrw)

このレッスンで:
+ 由来された言語構造(derived language constructs)、つまり、意味論が全部他の構造から取られた物を定義する方法
+ 予め定義される構文カテゴリに、新たな構造を加えること

これらのことを見ていきます。

言語を定義する時に、すでに定義される構造を使って新たな構造を定義したいこともよくあります。例えば`let`構文を使う変数束縛：

```
    let x = e in e'
```

その`let`表現は `(lambda x . e') e` 上の構文糖衣だけです。規則を使ってこのようなことを簡単に定義できます。`lambda.k`で例示が見えます。

`lambda.k`をコンパイルして、`let`を使うプログラムを書いてみよう。例えば`arithmetic.lambda`の中にある整数を`let`で束縛されている変数と交換するプログラムを`lets.lambda`として書きましょう。`arithmetic.lambda`と同じく、`true`になるはずです。

次に、10の階乗を計算するプログラムを見てみましょう：

```
    let f = lambda x . (
            (lambda t . lambda x . (t t x))
            (lambda f . lambda x . (if x <= 1 then 1 else (x * (f f (x + -1)))))
            x
          )
    in (f 10)
```

このプログラムは型無しラムダ計算式でよく見えるフィックスポイントを定義する手続きで使って定義されます。その手続きは関数に自分のことを引数として渡すことです。

このように定義することは再起的にならせたい関数のボディーの中にグローバル変更が必要となるので(今回は`f f`を自分に渡すこと）再起的関数はこのように定義したくないかもしれない。
以下に実演される手続きは関数の再起的部分を`fix`と呼ばれる「fixed-point combinator」に分離して、階乗関数のボディー対適用します。

```
let fix = lambda f . (
          (lambda x . (f (lambda y . (x x y))))
          (lambda x . (f (lambda y . (x x y))))
        )
in let f = fix (lambda f . lambda x .
                (if x <= 1 then 1 else (x * (f (x + -1)))))
   in (f 10)
```

こういう概念は面白くて、かなり力を持っていますが、プログラマーはこのようにもプログラムを書きたくい訳がないと思います。

関数プログラミング言語でよくみえる`letrec`と呼ばれ、より深い由来される構造を簡単に定義可能です。`letrec`の意味論は上記の「fixed-point」概念を捕獲します。`letrec`の定義を直感的に書けるため、引数を一つ受けられるように実装します。

```
 syntax Exp ::= "letrec" Id Id "=" Exp "in" Exp
```

```
  rule letrec F:Id X:Id = E in E'
    => let F =
         (lambda $x . ((lambda F . lambda X . E) (lambda $y . ($x $x $y))))
         (lambda $x . ((lambda F . lambda X . E) (lambda $y . ($x $x $y))))
in E' [macro]
```

ここで注意していけば良いところが二つあります。

+ ベタ縮小とそれでの置換の繰り返しを一回減らすために、階乗の定義に`fix`コンビネーターのインライン化しました。残っている`let`もインライン化可能だったんですが、やらないほうが読みやすいと思います。
+ `Id`構文カテゴリーを新たな定数(`$x`と`$y`)と拡張しました。プログラムで使用可能なビルトイン半名記号は`$`を接頭語として使用できないので、この意味論と従うプログラムは`$x`と`$y`で始まる物体が保持する訳がありません。つまり、意味論の定義に使えるけどプログラムに使えない物を`Id`に追加することで、その追加したものは意味論に貸し切られているようになれます。`letrec`で定義された関数のボディーにある全ての`$x`は`lambda $x`にキャプチャーされますから、これは確かに望ましいです。

`letrec`を使って、階乗関数を関数プログラミング言語で可能な限り綺麗に書けるようになりました。

```
letrec f x = if x <= 1 then 1 else (x * (f (x + -1)))
in (f 10)
```

次回はフィックスポイントを定義するために特製の`mu`バインダーを使って代替的な`letrec`の定義を見ます。