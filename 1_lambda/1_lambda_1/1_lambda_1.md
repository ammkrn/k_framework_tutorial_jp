# 前書き

このチュートリアルより入門向けのプログラミング言語を分析する教科書が欲しい方々に、ここにある第二巻(赤いの)「programming language foundations」がおすすめです。
https://www.chiguri.info/sfja/

* あらかじめ作成kツールもチュートリアルのソースファイルも含む仮装マシーンイメージは下のリンクからダウンロード可能。
http://www.kframework.org/index.php/K_tool_binaries

+ virtualboxから machine -> add -> ダウンロードしたファイルを選んで。
+ 注意：予め作成仮装マシーンイメージはエディターなら vi しかインストールされていません。

# 1.1 構文モジュールと基本的なk命令

[元講座動画へのリンク](http://youtu.be/y5Tf1EZVj8E)

このレッスンで、「LAMBDA」プログラミング言語の構文をｋモジュールとして定義しながらｋの基本を調べていきます。そのため、テキストエディターに「lambda.k」というファイルを作って開けて下さい。命令をｋツールズに伝えるため、ターミナルを使います。

kは普通のプログラミング言語と同様に、コードをカプセル化するためのモジュールシステもを持ちます。kモジュールを開始・終了することはそれぞれ`module`と`endmodule`キーワードで出来ます。`syntax` キーワードで言語の定義に新たなプロダクションルールを加えられます。ｋでプロダクションルールはバッカスナワーフォーム(BNF)という記号法で書かれます。「非終端記号」は普通にかかれて「終端記号」は囲み二重引用符で識別されます。`|` の分裂記号を使って同じ非終端記号対、プロダクションルールを複数に宣言可能です。

プロダクションルールにアトリビュート(特徴)を添付することも出来ます。アトリビュートは丸括弧に囲まれて、プロダクションルールの右に書いて置かれます。この場合、`left` アトリビュートって「ラムダ関数の適用は左結合である」ということを宣言します。例えば `left` アトリビュートは `a b c d` を `(((a b) c) d)` のようにパースさせます。構文構造をまとめるための丸括弧はプロダクションルールと `bracket` アトリビュートの組み合わせで加えます。そうすると丸括弧の「無視」意味論を手動で定義する必要がなくなります。技術的に言うなら、 `bracket` アトリビュートは「この構造をAST(抽象構文木)の自立ノードとして入れないで下さい」ということをパーサーに伝えてくれます。

現在定義しているラムダ計算式で識別子とラムダ抽象物は縮小出来ないもの、つまり「結果・値」、として見なされるようにします。しかし `Val` はここまで意味論を持たない一般的な非終端記号であります。意味論などのことはあとで対処します。

出来たら、以下の命令をターミナルから実行すれば LAMBDA の定義をコンパイル出来るはずです：

```
 kompile lambda.k
```

エラーが何も出なかったら、パーサーが k ツールずに作成されました。プログラムを実行するための `krun` 命令で召喚される道具はこれから発生したばかりのパーサーをデフォールトで使用します。パーサーが役に立つかどうかを見るため、`.lambda` の拡張子を持つプログラムをいくつか書いて実行しましょう。

`tests` フォルダーでも見える `identity.lambda` というラムダ恒等関数入りのプログラムはこれ：

```
lambda x . x
```

`krun` を召喚して `identity.lambda` を実行してみてください。`krun` は言語の定義を持つダイレクトリーから呼ばなければなりません。`krun --help` でいろんなオプションや補助フラグが見えます。

```
krun identity.lambda
```

出てくるのは：

```
<k>
    lambda x . x
</k>
```

このような出力が返されたら、プログラムが問題なくパース、プレぃティープリントされました。`krun` の代わりに `kast` 命令でプログラムを実行すると内部のAST・抽象構文木が見えます。

```
kast identity.lambda
```

こんなに恐ろしいものを見る必要がないはずなので心配しないで下さい。確かに綺麗なものではないんだが、kの出力を道具に書き込むためにすごく便利な記号法になります。

プログラムを実行した時、`krun` はプログラムを全体 `<k> ... </k>` セルに入れましたね。k の文脈で、計算は全部セル中に行われます。「コンフィギュレーション」を明示的に定義しないとプログラムを持つ`<k>`セルを持っているコンフィグが自動的に作ってくれたんです。

(翻訳者からのノート : コンフィギュレーションは後のレッスンで深く説明されますが、それはプログラムの全体の構成・枠組みのように考えられます)

次に、free-variable-capture.lambda というプログラムを書きましょう。このプログラムが LAMBDA の置換に基づく意味論で正しく評価されるため、置換演算は変数キャプチャーを避けていくことが必要です。

```
a (((lambda x.lambda y.x) y) z)
```

それで、`closed-variable-capture.lambda` というプログラムもキャプチャーぬきの置換が必要な表現を持ちますが対照的にこの表現は閉じています。つまり、自由変数を何も持たなくて全ての束縛されている変数は一位的であります:

```
(lambda z.(z z)) (lambda x.lambda y.(x y))
```

最後に `omega.lambda` プログラムに、典型的な omega combinator が書いてあります。これは永遠に繰り返す表現からの一番小さいなやつです。(後のレッスンでLAMBDAの定義を完成する前になにもしないけどさ)

```
(lambda x.(x x)) (lambda x.(x x))
```

パーサーに慣れるため、他のプログラムを書いてみてもいいと思います。パーサーのエラーにも慣れるため壊れてるプログラムも書いても悪くないんです。次のレッスンで、初めての ｋ で定義されるプログラミング言語をちゃんと手に入れるために、定義した構文から由来する表現が「値」まで評価するための連続的に適用可能な意味論的な書き直し規則の定義する方法を検査します。


