# ビルトインと補助条件を追加する

[元講座動画 [4'52"]](http://youtu.be/T1aI04q3l9U)

ここまで、識別子のソート `Id` を既にLAMBDAに加えたが、`Id` を処理する意味論規則がありません。このレッスンで、整数と真偽値のビルトインソートをLAMBDAに引き入れて、それらのソート対の演算を定義する方法を調べます。補助条件式を使って書き換え規則が適用される事情をコントロールすることもやります。

k は各々の定義が自動的に輸入するビルトイン物を定期要します。ビルトインを望みの構文カテゴリに加えることで明示的に使えます。デフォールトで提供されるビルトインは自分のユースケースト合わない場合は、新たなビルトインを定義することも出来ます。ちなみに、でフォールドで提供されるビルトイン整数ソートは任意精度であります。

さて、整数・真偽値を LAMBDA に引き入れることはこのように行われます：

```
    syntax Val ::= Int | Bool
```

`Int` と `Bool` はビルトインと対応する非終端記号です。

導入したばかりのビルトインを用いるため、言語に数学演算と対応する構造も加えないとね。今回、中置記号を普通の優先と実装します (掛け算とわり算のほうが足し算より強く結合します)。[SDF](http://www.syntax-definition.org/) に触発されて、構文構造の分裂記号 `|` を `>` と交換すれば「`>`記号の前に定義されている構造の方が、後で定義されている構造より強く結合するようにしたい」ということを k に伝えられます。`lambda.k`で例示が見えます。この機能を使って数学演算子の優先を簡単に宣言出来ますね。

一つだけの残っている任務は定義したばかり数学演算を引き入れたビルトイン整数ソートと繋ぐことです。`lambda.k`で見えるように、かなり分かりやすい書き換え規則で出来ます。ビルトイン対の演算と自作の演算を識別することを用意にするため、k のビルトイン演算は自分の名前を語尾として持っております。例えば、ビルトイン整数の足し算は `+Int` で書かれます。

修正した `lambda.k` をコンパイルして、簡単な数学表現を評価してみましょう。tests ダイレクトリーにある `arithmetic.lambda` はこれ： 

```
`(1+2*3)/4 <= 1`
```

`krun arithmetic.lambda` が思い通りに `true` に評価されます。定義した優先が正しく反映されます！

無駄な計算が渡されたら何が起こるかを見てみましょう。古典的な0割にします。内容プログラムが `1/(2/3)` である`arithmetic-div-zero.lambda` を見てください。現在の LAMBDA 定義によって割り算は正格評価を使うので `2/3` は `0` になるはずで、書き換え後 `1/0` になります。k バージョン・コンパイラーのバックエンドによっていろんなように解釈されるわけです。デフォールトのバックエンドなら、 `1/Int 0` になったら計算が詰まってるようになってしまいます。

勿論、無駄な計算のせいで進めなくなることなどの事情は嫌ですから、避ける方法がいろいろあります。今回、除算の意味論を制御する規則に補助条件式を添付して困る物になれない計算しか受けられない物にする：

```
 rule I1 / I2 => I1 /Int I2 requires I2 =/=Int 0
```

新たに加えた部分は `requires I2 =/=Int 0` ですね。

他の演算形式主義と同様に k の補助条件式の目的は、規則が当て嵌まる事情を濾過することです。補助条件式の概念は「論理」から由来します。形式な論理の文脈で、補助条件式はかなりやすいけど論理前提は費用が高いものであります。論理前提を解けることはまた高い論理由来物を使うことで行われます。一方補助条件式は基盤となる論理領域のメタヴァリアブル対のかなり安い条件であります。後のレッスンで見ますが、その基盤となる論理領域はユーザーが拡張可能な物です。論理として見なされたら、k は何かの元と扱われている書き換え規則から新たな書き換え規則を由来します。従って補助条件式内の表現は書き換えを持ちません。この特徴は Maude などの書き換えエンジンと対照的です。

この限りのきっかけが二つあります:
1. 万能用の書き換え規則を使うことは複雑でより早い書換エンジンが必要です。そのようなエンジンは再帰的 (時として虱潰し式の) 書き換えセッションをやります。一方、k の補助条件式はいろんなバックエンドにビルトイン表現・関数を評価することによって効率が高いように処理可能な物です。
2. k の「semantic definitional philosophy（意味論定義哲学）」は論理前提が必要不可欠ではありません。それに伴って、前提をサポートする必要もありません。

ビルトイン数学を使うことはかなり有用なんですが、ラムダ表現とビルトインだけでプログラムを書くことはまだ面倒くさいですね。だから、次のレッスンで if文・変数束縛・再起を LAMBDA に加えていきます。
