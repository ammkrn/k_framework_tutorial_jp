# 前書き

このチュートリアルより入門向けのプログラミング言語を分析する教科書が欲しい方々に、ここにある第二巻(赤いの)「programming language foundations」がおすすめです。
https://www.chiguri.info/sfja/

* あらかじめ作成kツールもチュートリアルのソースファイルも含む仮装マシーンイメージは下のリンクからダウンロード可能。
http://www.kframework.org/index.php/K_tool_binaries

+ virtualboxから machine -> add -> ダウンロードしたファイルを選んで。
+ 注意：予め作成仮装マシーンイメージはエディターなら vi しかインストールされていません。

# 1.1 構文モジュールと基本的なk命令

[元講座動画へのリンク](http://youtu.be/y5Tf1EZVj8E)


このレッスンで、「LAMBDA」プログラミング言語の構文をｋモジュールとして定義しながらｋの基本を調べていきます。そのため、テキストエディターに「lambda.k」というファイルを作って開けて下さい。命令をｋツールズに伝えるため、ターミナルを使います。

kは普通のプログラミング言語と同様に、コードをカプセル化するためのモジュールシステもを持って、kモジュールを開始・終了することはそれぞれ`module`と`endmodule`キーワードで出来ます。言語の定義に新たなプロダクションルールは`syntax`キーワードで追加されます。ｋでプロダクションルールはバッカスナワーフォーム(BNF)で書かれます。「終端記号」は囲み二重引用符で識別されます。`|` で書かれる分裂記号を使って、同じ非終端記号対、プロダクションルールを複数に宣言可能です。

プロダクションルールにアトリビュート(特徴)を添付することも出来ます。アトリビュートは丸括弧に囲まれて、プロダクションルールの右に書かれます。この場合、`left`アトリビュートって「ラムダ関数の適用は左結合である」ということを宣言します。例えば`left`アトリビュートは`a b c d`を`(((a b) c) d)`のようにパースさせます。構文構造をまとめられる丸括弧を追加するため、`bracket`アトリビュートを使います。そうすると丸括弧の「無視」意味論を手動で定義する必要がなくなります。技術的に言うなら、`bracket`アトリビュートは「この構造をAST(抽象構文木)の自立ノードとして加えないで下さい」ということをパーサーに伝えてくれます。

ここで定義しているラムダ計算式で識別子とラムダ抽象物は縮小出来ないもの、つまり「結果」、として見なされるべきです。しかし`Val`はここまで意味論を持たない普通の非終端記号であります。意味論などのことはあとで処理します。

出来たら、以下の命令でここまでの定義をコンパイル出来ます。

```
 kompile lambda.k
```

エラーが何も出なかったら、パーサーが作成されました。`krun`で召喚される道具はこれから発生したばかりのパーサーをデフォールトで使用します。パーサーが役に立つかどうかを見るため、`.lambda`拡張子付きのプログラムをいくつか書いて見ましょう。

以下のラムダ抽象物を持つファイルを作って、`identity.lambda`として保存して下さい。
```
lambda x . x
```

以下の命令で`krun`を召喚して`identity.lambda`を実行しましょう。`krun`は言語の定義を保存しているダイレクトリーから読んで下さい。`krun --help`で言語の定義をkrunへ明示的に渡す方法も説明されます。

```
krun identity.lambda
```

`krun` が以下のことを出すはずです。

```
<k>
    lambda x . x
</k>
```

このような出力が見えるなら、プログラムが問題なくパース、プレぃティープリントされました。内部のASTが見たければ`krun`の代わりに`kast`で実行することで見えます。

```
kast identity.lambda
```

こんなに恐ろしいものを見る必要がないはずなので心配しないで下さい。確かに綺麗なものではないんだが、道具に書き込むためにすごく便利な書き方になります。

プログラムを実行した時、`krun`はプログラムを全体`<k> ... </k>`セルに入れましたね。kツールの文脈で、計算は全部セル中に行われます。「コンフィギュレーション」を明示的に定義しないとプログラムを持つ`<k>`セルしか入ってないのが自動的に作ってくれたんです。

(翻訳者からのノート : コンフィギュレーションは後のレッスンで深く説明されますが、それはプログラムの構成・枠組みのように考えられます)

次に、free-variable-capture.lambdaというプログラムを書きましょう。このプログラムがLAMBDAの置換元の意味論の立場から正しく評価されるため、置換演算は変数キャプチャーを避けていかないとなりません。

```
a (((lambda x.lambda y.x) y) z)
```

それで、`closed-variable-capture.lambda`というプログラムもキャプチャーぬきの置換が必要な表現を表します。けど今回の表現は閉じています。つまり、自由変数を何も持っていません。

```
(lambda z.(z z)) (lambda x.lambda y.(x y))
```

最後に`omega.lambda`プログラムに、典型的な omega combinator が書いてあります。これは永遠にループする表現からの一番小さいなやつです。(後のレッスンでLAMBDAの定義を完成する前になにもしないけどさ)

```
(lambda x.(x x)) (lambda x.(x x))
```

パーサーに慣れるため、他のプログラムを書いてみてもいいんです。パーサーのエラーに慣れるために壊れているプログラムも書いてみて。次のレッスンで、初めてのｋで定義されるプログラミング言語をちゃんと手に入れるために、定義した構文から由来する表現が「値」まで評価するための連続的に適用可能な意味論的な書き直し規則の定義する方法を検査します。


