# モジュールを輸入すること、規則、変数

[元講座動画 [4'03"]](http://youtu.be/NDXgYfHG6R4)

このレッスンで:

+ あらかじめ定義された SUBSTITUTION モジュールを輸入する方法
+ そのモジュールを使って規則を定義する方法
+ 規則中に変数を使う方法

などのことを調べていきます。

前回書き始めた `lambda.k` を続けましょう。

`requires` キーワードは `.k` の拡張子が付くファイルを言語の定義に導入します。デフォールトで引き入れられるモジュールは `k/include` に位置付けられます。で、`require substitution.k`は「以下の定義に `k/include` に位置している汎用的置換演算を持つモジュールが必要だ」ということを宣言します。もちろん k を使って自分の置換演算を定義出来ますが、そうすることはここまで語ったことがないフィーチャが要るので今回はビルトイン定義を使います。

それから、`imports` キーワードを使って `requires` で導入したファイルからのSUBSTITUTIONモジュールを現在のモジュールに輸入可能です。

さてと、インポートした置換演算は汎用的であります。つまり、その置換演算は自分で LAMBDA 言語の構造からどれが変数を束縛するか、どれが変数としてあるかっていうことは識別できません。しかし、「変数キャプチャー問題」を解決するためにそれらのことを識別することが必要な機能です。以下の二つのことを我々の置換演算に伝えていくと解決できます：

1. ラムダ構造は「束縛する物・バインダー」にしたいこと

これは `binder` アトリビュートを使って伝えられます。`binder` のデフォールト行動は目標構造の第一引数にある全変数を覚えて、あとの出現で変数をバインドします。 

例えば
```
"lambda" A "." Z   [binder]
```

"lambda" と "." は普通の終端記号で、A と Z はラムダ構造の引数としてあります。`binder` はAの中にある変数を見て、それで見つけた変数がZに出現すればそれをバインドします。どれの引数がバインドされるか、どこにバインドされるかってことは手動で変更できますが、それは後のレッスンで見ます。

2. 束縛と置換において、どれの項が変数として扱うべきですか

これを k に伝えるため、特別のビルトインソート `KVariable` を使います。変数扱いにしたい項は KVariable としてサブソートします。

出来たら、初めての k 規則(書き換え・書き換え規則)を書きましょう。規則は `rule` キーワードで宣言されて、`=>` で書かれる「書き換え記号」を用います。今回はラムダ計算式の「ベタ縮小」を定義します。チュートリアルが含む完成版のLAMBDA定義で見えるように、このルールの置換は右側対行われます。慣例では、ルールにある変数は大文字で始まります。バージョンによってそれは k で強制されるかもしれません。

規則中の変数なら、ソートを明示的に添付可能です。ランタイムで、タグ付きの項は正しいソートを持つかどうかが確認されます。タグが付いていなければ、その確認が実行されません。タグを付けることがより安全ですが、ソートチェックは自立の計算になるのでタグが付いていないほうが早いんです。

LAMBDA の定義をコンパイルしてプログラムをいろいろ実行しましょう。例えば、

```
    krun closed-variable-capture.lambda
```

出てくるはずの結果はこれ：

```
    <k>
      lambda y . ((lambda x . (lambda y . (x  y))) y)
    </k> 
```

縮小するプログラム、縮小しないプログラム、停止しないプログラム(例えば omega.lambda) もありますね。例えば `free-variable-capture.lambda` は意外と二番目の引数を `y` まで縮小しません。なぜならば、k の書き換え規則は明示的に許可されるところにしか適用しないんだからです。適用する許可は各言語構造の評価戦略から由来されて、評価戦略は後のレッスンで見る「正確アトリビュート」、「評価文脈」、「温め・冷めルール」などのことに指定されます。次回は、「正確評価」というアトリビュートを使って望みの評価戦略を手に入れる方法を調べていきます。
