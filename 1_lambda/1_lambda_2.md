 Module Importing, Rules, Variables
# モジュールを輸入すること、規則、変数

[元講座動画 [4'03"]](http://youtu.be/NDXgYfHG6R4)

今回は:

+ あらかじめ定義されたSUBSTITUTIONモジュールを輸入する方法
+ そのモジュールを使って規則を定義する方法
+ 規則中に変数を使う方法

などのことを調べていきます。

前回書き始めた`lambda.k`を続けましょう。

`requires`キーワードは拡張子が`.k`であるファイルを言語定義に導入します。デフォールトで引き入れられるモジュールは`k/include`に位置付けられます。で、`require substitution.k`は「以下の定義に`k/include`に位置している汎用的置換演算を持つモジュールが必要だ」ということを宣言します。
もちろん k を使って自分の置換演算を定義出来ますが、そうすることはここまで語ったことがないフィーチャが要るので今回はビルトイン定義を使います。

それから、`imports`キーワードを使って`requires`で導入したファイルからのSUBSTITUTIONモジュールを現在のモジュールに輸入可能です。

さてと、インポートした置換演算は汎用的であります。つまり、LAMBDA言語の構造からどれが変数を束縛するか、どれが変数としてあるかっていうことはまだ識別出来ません。しかし、「変数キャプチャー問題」を解決するためにそれらの機能が必要です。この競合を解決するために我々の置換演算に二つのことを伝えていきます。

1. ラムダ構造は「束縛するもの・バインダー」にしたいこと

これは`binder`アトリビュートを使って伝えられます。`binder`はデフォールトで目標構造の第一引数にある全変数を、後の引数の中にいずれか存在している位置とバインドします。

例えば
```
"lambda" A "." Z   [binder]
```

"lambda" と "." は普通の終端記号で、A と Z はラムダ構造の引数としてあります。`binder`はAの中にある変数を見て、その変数がZにあったら、Zのなかにある物をバインドします。どれの引数がバインドされるか、どこにバインドされるかってことは手動で変更できますが、それは後の講習で見ます。

2. 束縛と置換において、どれの項が変数として扱うべきですか

これをKツールに伝えるため、特別のビルトインソート`KVariable`を使います。変数扱いにしたい項はKVariableとしてサブソート(部分ソート)します。

出来たら、初めての k 規則を書きましょう。規則は`rule`キーワードで宣言されて、`=>`で書かれる「書き直し記号」を用います。今回は、ラムダ計算式の「ベタ縮小」を定義します。チュートリアルが含む完成版のLAMBDA定義で見えるように、このルールの置換は右側に行われます。

慣例では、ルールにある変数は大文字で始まります。kツールのバージョンによって、それは強制的であるかもしれません。

規則にある変数に、ソートを明示的に添付可能です。ランタイムで、タグ付きの項は正しいソートを持つかどうかがチェックされます。タグが付いていなければ、その確認が実行されません。タグを付けることがつけないことより安全が、ソートチェックは自立の計算としてあるので、タグが付いていないほうが早いんです。

出来たら定義をコンパイルしていろいろプログラムを実行しましょう。例えば、

```
    krun closed-variable-capture.lambda
```

実行すれば、結果は：

```
    <k>
      lambda y . ((lambda x . (lambda y . (x  y))) y)
    </k> 
```

ここまでの定義で縮小するプログラムも縮小しなプログラムもあって、例えば`free-variable-capture.lambda`は二番目の引数をちゃんと`y`まで縮小しません。`omega.lambda`のような停止しないプログラムもあります。この行動のきっかけは、kの書き直し規則は明示的に許可されるところにしか適用しないんだからです。適用する許可は各言語構造の評価戦略から由来されて、評価戦略は後のレッスンで見る「性格アトリビュート」、「評価文脈」、「温め・冷めルール」に指定されます。

次回は、「性格評価」のアトリビュートを使って望みの評価戦略を定義する方法を調べていきます。
