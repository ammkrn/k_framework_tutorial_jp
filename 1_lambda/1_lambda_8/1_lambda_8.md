# 束縛する構造の交流

[元講座動画 [2'40"]](http://youtu.be/Ox4uXDpcY64)


今回、いろんな興味深い再帰的関数をエレガントに定義可能な `mu` バインダーを調べながら変数を束縛する構造が複数ある時の交流を見ます。

実を言うと `mu` の構文は名前以外ラムダと同じです。ちゃんとバインダーにするため、`binder` アトリビュートを添付することが必須です。

```
  syntax Exp ::= | "mu" Id "." Exp [binder]
```

もっとも汎用的な `mu` を用いる表現はこれですね:

```
mu x . e
```

この表現についての直感的な考え方は「表現が `e` まで縮小されて、返された `e` の中にある全ての `x` が `mu x . e` として書き換えられる」と言うことです。

`mu` の意味論を形式的に定義する前に `letrec F X = E in E'` を `mu` から由来しましょう。目的は `F` を `lambda X . E` のフィックスポイントとして考えることだけです。つまり、`mu F . lambda X . E` を計算して F が `let F = mu F . lambda X . E in E'` と言うフィックスポイントに束縛されている E' を評価することです。

この新たな `letrec` はまだ分かりにくそうかもしれませんが (特に `F` が二回バインドされるってこと) 前回の定義よりこっちの方が簡単で綺麗であります。それ以上、この定義は型安全性を守ります（そのことはこの章の範囲外ですが）

最後に `mu` の意味論を定義する時点に達しました。意味論は簡単に、`E` 中の自由な `X` を `mu X . E` と置換することです。

```
    mu X . E => E[(mu X . E) / X]
```

`lambda.k` をコンパイルして、再帰的プログラムを実行して見て。前回の定義と比較したら、数倍早くなったはずです。

おめでとうございます！k を使って最初のプログラミング言語を完成しました！レッスン9が存在しますが、主眼となる k-doc 道具はまだ開発中ので現在使用出来ないものです。従ってそれを注目するレッスンはこのチュートリアル含まれません。
