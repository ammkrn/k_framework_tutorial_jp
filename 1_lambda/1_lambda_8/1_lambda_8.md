# 複数のバインドする構造

[元講座動画 [2'40"]](http://youtu.be/Ox4uXDpcY64)

今回は、変数を束縛する複数の言語構造の交流を見ていきます。いろんな面白い再起的関数を定義可能有名な`mu`バインダーも見ます。

`mu`バインダーの構文はラムダと同じです。`lambda`と同じく、`mu`はバインダーとして正しく作動するため、言語に`mu`をバインダーとして注記する必要があります。そうするとき、望みのlatexアトリビュートも飾りつけられます。

```
mu x . e
```
の直感的な考え方は、表現が`e`に縮小しますが、`e`の中にあるすべての自由な`x`が`mu x . e`で置換されます。

`mu`はそろそろ定義していくけど、その前に`letrec F X = E in E'`を`mu`から由来する構造として再定義しましょう。やりたいことは、`F`を`lambda X . E`のフィックスポイントとして考えることです。つまり、以下の表現を計算して、

```
mu F . lambda X . E
```

それから`F`が以下のフィックスポイントに束縛されれているように`E'`を計算する

```
let F = mu F . lambda X . E in E'
```

この新たな`letrec`はまだ分かりにくそうかもしれませんですが（特に`F`が二回バインドされること）前の定義よりこっちの方が簡単で綺麗であります。それ以上、この定義は型安全性を持っています（そのことはこの章の文脈外ですが）。

早速`mu`の意味論を定義する規則を書きましょう。

意味論は簡単に、`E`中の自由な`X`を`mu X . E`と置換することです。

```
    mu X . E => E[(mu X . E) / X]
```

`lambda.k` をコンパイルして、再帰的プログラムを実行して見て。前回の定義と比較したら、数倍早くなったはずです。

それで、kを使って最初のプログラミング言語を定義しました！次回、配達、教える、出版することを容易にするため、kツールで言語をちゃんとドキュメントする方法を習っていきます。
