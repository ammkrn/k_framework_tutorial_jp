# 由来構造・あらかじめ作成構文を拡張すること

[元講座動画 [5'10"]](http://youtu.be/qZWiBaN7zrw)

このレッスンでの題:
+ 由来された言語構造(derived language constructs)つまり、意味論が全部他の構造から取られた物を定義する方法
+ 予め定義された構文カテゴリに新たな構造を加えること

言語を定義する時に、すでに定義された構造を使って新たな構造を定義したいこともよくあります。変数を `let` 文で束縛することはいい例示です：

```
    let x = e in e'
```

このような `let`　文は `(lambda x . e') e` を包む構文糖衣だけです。このような再利用を用いる定義は書き換え規則で作れます：

```
syntax Exp ::= "let" Id "=" Exp "in" Exp
rule let X = E in E':Exp => (lambda X . E') E [macro]
```

`lambda.k` をコンパイルして、`let` を使うプログラムを書いてみよう。`arithmetic.lambda` の変数束縛が `let` 文と交換されたプログラムは以下のような物で、これも `true` になるはずです：

tests/lets.lambda
```
let a=1 in
  let b=2 in
    let c=3 in
      let d=4 in
((a+b*c)/d <= a)
```

次に、10の階乗を計算するプログラムを見てみましょう：

```
    let f = lambda x . (
            (lambda t . lambda x . (t t x))
            (lambda f . lambda x . (if x <= 1 then 1 else (x * (f f (x + -1)))))
            x
          )
    in (f 10)
```

このプログラムは型無しラムダ計算式でよく見る「フィックスポイント」を使って書かれるんです。再帰的な関数を定義するため、関数を自分のことへ渡すことです。

再帰的関数をこのように定義するのはグローバル変更が必要となるので、以下のように「フィックスポイント」の特徴を「フィックスポイントコンビネータ」で分離することがより望ましいです。そうすると、階乗を計算する関数のボディーはこれ：

```
let fix = lambda f . (
          (lambda x . (f (lambda y . (x x y))))
          (lambda x . (f (lambda y . (x x y))))
        )
in let f = fix (lambda f . lambda x .
                (if x <= 1 then 1 else (x * (f (x + -1)))))
   in (f 10)
```

この概念は興味深くてかなり火力を持ちますがプログラマーとしてこのようなことって書きたくありませんね。

関数プログラミング言語でよく見える `letrec` 文を由来構造として定義することも出来ます。`letrec` は上記の「フィックスポイントコンビネータ」の意味論を抑えるものであります。定義を簡単に書けるため引数を一つだけ受ける構造にします。

```
 syntax Exp ::= "letrec" Id Id "=" Exp "in" Exp
```

```
  rule letrec F:Id X:Id = E in E'
    => let F =
         (lambda $x . ((lambda F . lambda X . E) (lambda $y . ($x $x $y))))
         (lambda $x . ((lambda F . lambda X . E) (lambda $y . ($x $x $y))))
in E' [macro]
```

注意すれば良いところが二つあります。

+ ベタ縮小とそれでの置換の繰り返しを一回減らすために、階乗の定義に `fix` コンビネーターをインライン化しました。残っている`let`もインライン化すればいいけど、やらないほうが読みやすいと思います。
+ `Id` の構文カテゴリに新たな定数(`$x`と`$y`)を加えました。プログラム中に `$` から始まる識別子は許されないので、この意味論で実行されるプログラムは `$x` と `$y` 識別子が保持する訳がありません。`letrec` の定義を考えたらこのように識別しを意味論に貸し切ることの有用さがわかると思います。

`letrec`を使って、階乗関数を関数プログラミング言語で可能な限り綺麗に書けるようになりました。

```
letrec f x = if x <= 1 then 1 else (x * (f (x + -1)))
in (f 10)
```

次回はフィックスポイントを定義するために特製の `mu` バインダーから由来される代替的な `letrec` を定義する方法を調べます。