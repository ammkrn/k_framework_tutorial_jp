## 全変更：構文、コンフィグ、意味論

今回 `thread joining` という最も簡単なスレッド同期機構の一つを imp++ に加えます。そのため、コンフィグにあるスレッドが一意的な識別子をもたせていって、`spawn` で作った子供スレッドの識別子をメインスレドへ返されるようにします。色んな小さいけど火力・コンパクトさを上げる変更もします。

始める前に、レッスン 1 からの `spawn.imp` プログラムの定義をコピペして下さい。レッスン６でメインスレッドが子供スレッドの前に停止して、望まない値を返す行動もあることを見ました。それをなおすため、子供スレッドに一意的な識別子を割り当てて子供スレッドが停止する (joinされる) までメインスレッドの print を遅延していきたいんです。新型を言語に加えたくないので、スレッドの識別子(id) を普通の整数で定義します。さてと `spawn.imp` に`t1` と `t2` という新しい整数を定義してそれぞれの `spawn` 命令に割れ当てます。

```
int x;
print("x = ");
x=read();
int t1; t1 = spawn {x=x/2;};
int t2; t2 = spawn {x=x+10;};  
print(x,"\n");
```

この書き方がパーサーに却下されないため、`spawn` を `statement` じゃなくて `AExp` にしないとならないんです。あっ、けどこうすれば `spawn` 内の `Stmt` も `spawn` 実体を終結する `;` を書いて `;;` になることはかなりブサくて分かりづらいです。その代わりに `spawn` を `Stmt` じゃなくて `Block` を受け取る物にすれば内部的なブロックを終結する `;` が必要ではなくなるのでやりましょう。

`spawn.imp` はまだ非決定的な所があります。なぜならば、子供スレッドはどの順序でも実行できて共有変数 `x` を競合する可能性もあります。ですが、今回より前のほうが可能な行動を持つはずです。完全に同期したければ二番目の子供スレッドを `join(t1)` 文で開始して最初子供スレッドが停止するまで実行できなくことも出来ます。そうすればこのプログラムは単一の行動があるはずです。

これから言語の意味論を変更しよう。スレッドのコンフィグに、`<id/>` というスレッドの一意的な識別子を持つセルを加えます。メインスレッドの id を 0 として初期化したいので、メインコンフィグに 0 を `<id/>` セルに入れます。`spawn` の規則がフレッシュ整数を識別子として発生して子供スレッドの `<id/>` セルに入れておきながら識別子のコピーを `spawn` の結果としてメインスレッドへ返すようにします。`join` 文を `stmt` 構文として加えます。`join` が起動される前に、join されてる子供スレッドの計算セルが空になったことが必要です。そのため、レッスン6からのスレッド掃除規則を削除します。`join` の意味論を実装することは色んなように出来ますが、今回は簡単に子供スレッドを捨てずにコンフィギュレーションで `join` 死体スレッドの `<id/>` を露出して、そのスレッドの `<k/>` せるが殻になったら `join` を起動するようにします。
自分で他のやり方と実験したければ、新たな `<done/>` セルを加えて、そのスレッドに停止したスレッドの識別にを保持するようにも来ます。

`spawn.imp` に `join` を入れて実行してみましょう :

```
int x;
print("x = ");
x=read();
int t1; t1 = spawn {x=x/2;};
int t2; t2 = spawn { /* join(t1); */ x=x+10;};  // uncomment for fully sync
join(t1);
join(t2);
print(x,"\n");
```

この版は前より構造が少ないはずです。二番目のジョインを uncomment すれば一つだけの行動があるはずです (これを --search で実行すれば複数の行動が出て変えるかもしれないけどフレッシュ変数のランダムに割り当てられた値だけが違います)。

`spawn` は変数を一で増やす演算と同様に副作用を起こせる構造です。副作用を起こすためしか実行されない関数 (発散関数とも言われ) を許す言語も多くあります。これは普通に式の果てしに `;` を付けて文に変えるようにやられます。例えば `++x;` は何も返さずに `x` を一で増やして結果が捨てられる文です。この機能も imp++ に加えましょう。どうするかというと、`AExp ";"` を `Stmt` プロダクションルールの右側に書いて `strict` 戦略を付けて意味論が `AExp` を評価して結果を捨てるようにすることだけです。

一方、変数宣言の右に付いてある `;` を削除することで代入文を式に変更することも許せます。これらの２つの規則を組んだらパース可能なプログラムの量が前より高くなってパースで出来なくなるプログラムがありません。例えば `x = y = z = 0` をパース出来るようになりました。

言語の定義を前よりコンパクトにするため、変更がもう一つあります。`Stmt` の連続を計算する規則を二項演算の代わりに `Stmt` 入りのリストを処理するものとして定義したいんです。こうすればブロックの構文を `{Stmts}` に変えて、`Stmts` ソートの空のリストも作れるようになるので空である `Block` はもういらなくなります。ですが、`.Stmts` が自分のことを溶かすようにしないとなりません。


事前に定義されて安定な言語を定義していなければ、自分の定義はよくこのようによく変更されるはずです。新たな構造を加えると、それは魅力的な変更を洗い出します。コンパクトである定義は大まかに言えば大きいやつより読み・変えやすくあるのでより望ましくあります。