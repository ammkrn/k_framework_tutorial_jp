# すでに存在する言語構文を拡張・変更すること

[元講座動画 [7'47']](https://www.youtube.com/watch?v=hWqJ8k9NNp8)

このレッスンで、すでに存在している言語の構文構造を汎用的にしたり新たな構造を加えたりすることで拡張する方法を見ていきます。

第二章からのIMP言語から始めていきましょう。

新たに加えたい構造は :
+ `++` : 変数の値を 1 増やす
+ `read` : 入力バファーから整数を読んで評価可能な物
+ `print` : `,`で区別される数学表現入りのリストを受けて、左から右の順番に評価して出力バファーへプリントしてくれる物にしたいんです。そのため、`print`の引数として渡せるリストである構文カテゴリを定義することが必須です。今回、`AExps`というものにします。我々は`print`を`strict`として定義していない事を注意して下さい。なぜならば、もし`AExps`、`print`のどちらかが`strict`で宣言されたら、リストがプリントされる前に渡された`AExps`リストの全要素が評価されます。で、そのリストの中に無駄な項があれば`AExps`は全体一つの無駄な計算として見なされて`print`は何も出さひません。けどリストアイテムを一度ずつ評価すれば、無駄な項は識別できるようになって、その項を評価されてないままでプリントも可能になります。

+ `halt` : プログラムを早速停止する物
+ `spawn` : 文を受けて、その文のコードを新たな並行スレッドで実行してくれます。新たに作ったスレッド(子供スレッド)は親スレッドの環境を共有するように書きます。

その上、`Stmt`/文と同じ使える場所がある局所的な変数宣言にを定義したいんです。局所的変数のスコープ・範囲は宣言時の位置からそのブロックの果てしまで続いて、変数シャドウイングも有効にします。構文の`Stmt`カテゴリに、局所的変数を宣言する文を加えることが最も簡単な実装する方法ですね。こうすると、「プログラム」は普通の`Stmt`になったので、`Pgm`という構文カテゴリを削除出来るようになりました。

構文をだいぶ変更しましたが、前バージョンのIMP用のプログラムは新バージョンがパース出来ます。しかし、新バージョンの立場から、プログラムは`Stmt`としてパースされるので`$PGM`というコンフィギュレーション変数を`Pgm`ソートから`Stmt`ソート物にします。終わったら、`sum.imp`などのプログラムを実行してみて下さい。

グローバル宣言の所に詰まっているようになってしまいますね。なぜならば、変数宣言は普通の`Stmt`と同じように扱われるようになったので、連続合成の規則が当てはまるので前バージョンのグローバル変数宣言を処理する規則が一致しなくなりました。前バージョンの立場から、変数宣言のプログラムは一つの物として存在していたので、無名変数を表す`_`記号を使って一致することが出来ました。しかし、今回は`...`で書かれる「セルフレーム変数」を用います。セルフレーム変数は`<k/>`セルに残ってい全部と一致します。最後に、変数宣言のリストが空になった場合の規則も変更することが必要です。リストの枠を溶かす物にします。

出来たら、全てのIMPプログラムをちゃんと実行できるようになりました。ですが、ここまでの意味論は未完成で、局所的変数向けのブロック意味論は正しくないんです。第二章からのIMPは局所的変数を持っていなかったのでこの問題が露出されていません。

しかし、この章の内容を少し覗いていきましょう。

`div.imp`は除算の評価戦略の非決定性と`++`演算の副作用を組んで、簡単で興味深いプログラムになります。このようなプログラムのあり得る行動を全部引き出す技術を後で調べます。

チャレンジ：`div.imp`の０割をやってしまう行動は発見出来ますか？

`io.imp`はIMP++の入出力機能を実演するプログラムです。正数を２つ読んで、正数と３つの文字列を出力するプログラムです。このプログラムはプログラム中の変数宣言も用います。

`sum-io.imp`は`sum`の対話的版です。

`spawn.imp`はメインスレッドと交流可２つのスレッドを動的に作って、xとのやり取りをするプログラムです。`spawn`の意味論を定義すると、行動がたくさん発生します。

最後、`locals.imp`は変数シャドウイングをテストするプログラムであります。

次回、新たに定義した構造のコンフィギュレーションを作って、コンフィギュレーションと意味論を合わせる方法も見ます。特に、状態のセルをLAMBDA++と同様に環境セルと蓄積セルに分割します。

