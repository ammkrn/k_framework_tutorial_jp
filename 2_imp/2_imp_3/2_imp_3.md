# 計算、結果、正格評価、セルを用いる規則

このレッスンで
+ `K`と呼ぶ計算を表す構文カテゴリ
+ 正格評価アトリビュートの本質（書き換え規則の構文糖衣だけだる）
+ 結果として扱われる計算を判明することの大事さ
+ セルを用いる規則の書き方

などのことを調べていきます。

### Kの計算

「計算構造」(単に*計算*)は計算の合成を表す `~>` 記号で区切られたリストから作られる物です。`~>`矢印は「から」・「または」で発音可能なセパレーターです。計算を表すための`K`と呼ぶ特性のソートがKに提供されます。Kのコンパイラーは`syntax`キーワードで宣言された構造を見たら、その物を自動的にKソートまで拡張してくれます。

`t1 ~> t2 ~> ... ~> tn`のような計算構造は順番にプロセスするべきタスクリストです。慣例では、初期化された計算はもとのプログラムだけでありますが、意味論の規則が繰り返し適用されば、だんだんタスク連続になります。

### 正格評価の論理

評価の正格さをコントロールするために、`strict`注記の右に、どれの引数が正格的に評価させたいってことを指定可能です。二番目の引数に対して正格評価を適用するのは`strict(2)`、二番目も三番目の引数に対して正格評価を適用する演算は`strict(2 3)`とそれぞれ注記されます。全引数を順番に正格評価を適用するっていう`seqstrict`注記もあります。`seqstrict`の宣言時に順番を明示的に指定しないと、左から右へ進むデフォールトが適用されます。

それらの正格評価を指定するための注記は内部的に一般的な書き換え規則と対応します。例えば代入の演算の`strict(2)`アトリビュートは以下の反対的な規則と対応しています：

(`X`が`Id`, `A`が`AExp`である)

```
    X=A; => A ~> X=[];
    A ~> X=[]; => X=A;
```


一行目は`A`を文脈から引き出して、プロセス可能なものにならせてくれます(この例で文脈は`X=A;`であり)。
ニ行目のルールは`A`を文脈に入れ戻します。

「化学抽象機械・(the chemical abstract machine)」に触発されて、一行目の規則を「温めルール」、ニ行目は「冷めルール」と呼びます。温めルールを連続的に適用すると、変数検索などの原子的なタスクが計算の上に上昇されて、他の規則の適用によって進歩可能な構造になります。進歩が出来たら、その計算の結果が冷めルールで文脈に入れ戻されて、温めルールが新たな縮小可能な項を洗濯していくっていうような循環になります。汎用的な足し算を表す温め冷めルールを例示として見ましょう:

```
    A1+A2 => A1 ~> []+A2
    A1 ~> []+A2 => A1+A2

    A1+A2 => A2 ~> A1+[]
    A2 ~> A1+[] => A1+A2
```

これらの規則を孤立させて見れば、非決定性を起こせる物でありますね。なぜならば、言語が指定している評価戦略が変わってゆくと、項の評価順番やその評価の結果も変わるので、同じ項はいくつかのように温められて冷められたかもしれませんね。

対照的に、`seqstrict`で実装された `<=` 比較演算はデフォールトで以下の温め・冷めルールと連想されます(`A1`と`A2`は`AExp`であって、`I1`って`Int`である)：

```
    A1<=A2 => A1 ~> []<=A2  // 左から始めて、A1を文脈から引いて縮小します
    A1 ~> []<=A2 => A1<=A2  // 縮小されたら、入れ戻す
    I1<=A2 => A2 ~> I1<=[]  // A2を評価するために取ります
    A2 ~> I1<=[] => I1<=A2  // 入れ戻されて、比較可能になった
```

つまり、`A1`の評価が終わるまで`A2`は評価されません。

温め・冷めルールはプログラムの評価を簡潔で揃いの書き換えルールに要約してくれますが、これらのやつは完全に可逆適用であります。そのまま適用すればプログラムが停止しなくて、kの定義を実行不可にしてしまいます。例えば、左結合的な足し算について考えたら、温めるのは `X + Y`の文脈から`X`引き、「`X`、その後 `[] + Y` に入れ戻す」連続を出力し、それからの冷めるのは「`X`を`[] + Y`に入れ戻して」という連続から、元の`X + Y`に戻ってしまいます。以下の句へ進んで、こういう無駄な未来を避けましょう。


# 実際の正格評価；ｋ結果

ｋの定義を効率的に実行可能になって、温め・冷めルールの可逆性を破るために、現在のｋツールはユーザーに書かれる「言語の結果」を判明する定義に頼ります。

kツールは`isKResult`と呼ぶ述語を提供して、言語構造を`KResult`ソートに加えていくと、`isKResult`が自動的にその構造まで拡張されます。実は、ｋツールは各構文カテゴリに対してこのような補助条件などが利用可能な述語を定義します。

言語の結果を判明する定義や指定された戦略評価(正格さなど)を参照して、`kompile`道具は温め冷めルールを変更して非停止性(nontermination)を避けます。例えば、実行可能な言語モデルが欲しければ、適用された変更は「温めルールが結果まで評価されてない物しか文脈から引き出せない、冷めルールが結果まで評価した項しか文脈に入れ直せない」ということです。形式的に：

```
 X=A; => A ~> X=[];  requires notBool isKResult(A)
 A ~> X=[]; => X=A;  requires isKResult(A)
```

これらの変更は non-termination を避けます。個数の行動が失われたが、今一つだけの行動が欲しいです。他のタスク向けの言語モデル(全行動を検査可能やつなど)が欲しければ、温め・冷めルールは`kompile`に別のように変更されます。計算機科学の立場から、行動を検査可能なモデルのほうが興味深いなものですがかなり遅くあるはずです。`kompile`ツールのゴールは作業の事情に応じて最も便利なモデルを出力することです。

# 「結果」になった項は道具で推論出来ませんか？

話せば長いことなんですが、一言で答えるなら *「いいえ」* 。推論出来る場合があるはずなんだが、問題がいろいろあるので、ｋツールは試しません。例えば詰まってしまった計算が結果として見なされることは確かに望ましくない行動だけど、詰まっている項を縮小するはずの規則を誤って書いてしまった・珍しいケースを処理する関数を書いて忘れてしまったことのせいでその悪い状態になるかもしれないね。kチームの経験によれば、大きい言語を書く時に何が結果にしたいってことについてゆっくり考えた方がいいです。しかし、実行されるはずがない言語定義は結果を判明しないでもいいんです。論理の立場から、温め冷めルールの可逆性は意味論の規則まで影響ないんだからです。

## セルを用いるｋ規則

ここまで書いた規則は全ていかの形がしていました：

`rule 書き換え前の項 => 書き換え後の項 requires 条件式`

初めてのセルを使う規則は:

`rule <k> X:Id => I ...</k> <state>... X |-> I ...</state>`

`<k>`セルが持っている計算は`~>`で分裂されているタスクの連続です。`state`セルはマップ(束縛の集合)を持って、各々の束縛は計算のペアであります。現在のkバージョンで、マップなどのビルトイン構造は型が付いてありません。だから、上の規則にあるセルは両方「コレクション」を持っています。`...`は*セルフレーム*と呼ばれ、意味は「物事がここにもありますが、規則の処理と関係ない物ばかりなので省略しています」ということです。`=>`の書き換え矢印は項のどこにもあり得ます。

上記の例は「`<k>`セルの最上タスクが`X`で、`X`が`state`のどこかに`I`と束縛されているなら、`X`が*局所的に*`<k>`セル中に`I`として書き直される」という意味の規則です。もちろん、この規則を普通の書き換え規則としても書けますが：

```
    rule <k> X ~> Rest </k> <state> Before (X |-> I) After </state>
      => <k> I ~> Rest </k> <state> Before (X |-> I) After </state>
```

けど、この書き方のほうが前のより長たらしくて間違いやすいです。その上にも、ｋの意味論で規則を*並行的な取引(concurrent transactions)*とも見なせます。その解釈なら、セルの文脈が読み出し専用部分としてあって、書き直されている項が読み書き可能な部分です。現在のｋコンパイラーは並行性を自動的に実装しないけど、複数の規則が読み出し専用の部分だけで重なるなら論理の立場からそれらの規則を同時に適用可能です。

今回はここまで！次のレッスンで、IMPの意味論を完成してやっと最初レッスンで見たプログラムを実行出来るようになります。
