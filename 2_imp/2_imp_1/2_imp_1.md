# もっと複雑な構文を定義する

第二章で、LAMBDAより複雑な C と似たような構文を持つ IMP 言語を定義します。

このレッスンの話題：
+ カプセル化を守るため言語の定義をいくつかのモジュールに分割すること
+ kのビルトインとしてあるセマンティクリスト構造の使い方

第一章でもちょっと触れたが k は定義している言語のフィーチャーをまとめるためのモジュールシステムを提供します。モジュールのまとめ方・構成を支配するルールか基準があまりないので自分の独断によって分割すればいいんです。この章で、IMP言語を２つのモジュールとして定義して、モジュールをそれぞれ IMP-SYNTAX と IMP を名乗っていきます。`imports` キーワードで、あるモジュールから他のモジュールを引き入れられます。名前の通り、IMPの構文をIMP-SYNTAX に書いて意味論を IMP に書きます。

k は輸入しているモジュールの内容を他のモジュールへ含めてくれるだけです（そうする内に、複数のモジュールを輸入する時にも各定義が一回以上定義されていないってことを保証します）。k のモジュールシステムはそれ以上何も特別なことをやりません。

IMPは六つの構文カテゴリを持つ言語になります。`imp.k` ファイルで全部見えます。数学表現の `AExp` 、真偽値表現の `BExp` 、ブロックの `Block` , 文の `Stmt` ,プログラムの `Pgm` と `Ids` という `,` で区別される変数名を持つリストです。ブロックは条件式の枝と while ループ文のボディーを限るための特別な文として定義されます。数学表現と真偽値表現は一般的に定義されます。

既に気づいたかもしれませんが、`<=` と `&&` は少しだけ皮をかぶせております。`<=` は `[seqstrict]` アトリビュートが付いてありますね。`seqstrict` という飾りは「引数が左から右へ順番に評価するべき」という意味です。`strict` と同様に、`seqstrict` は選択正格評価を指定すること許します。デフォールトで `seqstrict` は全ての引数対当て嵌ります。`&&` に短絡・ショートサーケットの意味論を持たせたいので、最初引数だけに正格評価を適用していきます。つまり、最初引数が `false` に評価されたら残りを評価せずに `false` を返せるのでやります。

ブロック (Blockソート) は波括弧で作られて、内容入り・内容抜きのブロックも作れるように定義します。

「文」(Stmt) は何も特別な行動を持ちません。しかし気をつけていけばいいところって `;` 文字は分裂記号として定義されなくて、代入文を停止するための記号として定義されます。Block は Stmt の部分ソートとしてあります。

構文より意味論に集中出来るため既にテストしたパーサーの優先を相続します。真剣にプログラミング言語を定義している場合、望みの行動を行ってくれるパーサーを手に入れることは優先との実験・いじることが大半の時に必要な作業になります。

IMPのプログラムは C のと同様に `int` キーワードから変数入り「,」で区別されているリストを宣言し、あとでいくつかの文を含むものです。この構文のきっかけは、与えられたIMPプログラムを `main(){..}` で囲んで行くと、有効な C プログラムになります。ここまでの IMP 言語なら、変数を宣言することは上にあるリストの文脈以外許されません。第四章で見る IMP++ 言語はこの限りを規制を解除します。

`,` で区別されるリストは `List{Id,","}` で定義されるのを注意してください。これは k がサポートしているビルトイン汎用的なリストです。大雑把にいうなら、このように宣言され：

```
syntax B ::= List{A,T}
```

この定義は新たな非終端記号 `B` を宣言し、リストの内容となるソートを `A` として判明する宣言です。`T`はリストの区別記号を表します。他の言語のリストと同じく、nil/何も入っていないリストもありえます。IMP なら、空のリストは変数がないプログラムを表しますね。他のkフィーチャーと同様に、リストの行動を詳しくコントロールする方法があります。

第一章と同様に正格評価アトリビュートがちゃんと役に立つため最終結果・値と見なされるべきの構造を指定することが必要です。IMP モジュールの中に `Int` と `Bool` を結果にしましょう。

`imp.k`をコンパイルして、プログラムを実行することで発生されたパーサーと実験して見て。IMP は C の部分だからテキストエディターを C モードにすれば、IMPのプログラムがちゃんとハイライトされるはずです。

`sum.imp`という例は`n`までの数の合計を`sum`変数と束縛します。
```
    int n, sum;
    n = 100;
    sum=0;
    while (!(n <= 0)) {
      sum = sum + n;
      n = n + -1;
    }
```

`krun sum.imp`をやってみて、パースーの出力を保持するkセルを見てください。

`collatz.imp`は`m`までの数に対して「コラッツの問題」を計算して、ステップの数を`s`に記録します。

```
    int m, n, q, r, s;
    m = 10;
    while (!(m<=2)) {
      n = m;
      m = m + -1;
      while (!(n<=1)) {
        s = s+1;
        q = n/2;
        r = q+q+1;
        if (r<=n) {
          n = n+n+n+1;         // n becomes 3*n+1 if odd
        } else {n=q;}          //        of   n/2 if even
      }
    }
```

`m`まで、素数がいくつあるってことを計算する`primes.imp`もあります。
```
    int i, m, n, q, r, s, t, x, y, z;
    m = 10;  n = 2;
    while (n <= m) {
      // checking primality of n and writing t to 1 or 0
      i = 2;  q = n/i;  t = 1;
      while (i<=q && 1<=t) {
        x = i;
        y = q;
        // fast multiplication (base 2) algorithm
        z = 0;
        while (!(x <= 0)) {
          q = x/2;
          r = q+q+1;
          if (r <= x) { z = z+y; } else {}
          x = q;
          y = y+y;
        } // end fast multiplication
        if (n <= z) { t = 0; } else { i = i+1;  q = n/i; }
      } // end checking primality
      if (1 <= t) { s = s+1; } else {}
      n = n+1;
    }
```

IMP の意味論を後のレッスンで完成するとこれらのプログラムは全部実行可能になります。前といったように、これらのプログラムを `main(){..}` で囲んでいくと好きな C コンパイラーでコンパイル・実行できます。IMPの意味論を定義する前に、`kast` と呼ばれる k のビルトインパーサーについていろんなことを明らかにしたいんです。我ながらかなり火力を持つ道具としてありますが、奇跡を行えるものではありません。kのパーサーはいろんな万能用なプログラミング言語をパースできますが(例えばこのチュートリアルにある2_languages/KOOL言語)本物のパーサーの代わりに使用されるようなものとしてデザインされませんでした。

k で定義される構文はすごく複雑なプログラミング言語の具体的な構文を完全に定義するために書かれたものではなく、意味論を定義する時の便利な記号法として書かれたものです。なので、kをよく*the syntax of semantics*と呼びます（意味論の構文って）。具体的な構文向けの外部パーサーをkツールと接続することの例示は公式チュートリアルのリポジトリの/samples/にあるKERNELC言語で見えます。

それが言われても、是非自分の言語をビルトインパーサーと合わせて見ることがおすすめです！構文ついての細かい問題処理したくないってこと言いながら自分の言語構文を諦めて行くことはやらないでください。本当にツールの短所のせいで言語を定義できないなら、Kチームに知らせてください。

このレッスンまで我々はデフォールトコンフェィギュレーションだけ見たことあります。次回、kのカスタムコンフェィギュレーションを定義する方法を見ていきます。


