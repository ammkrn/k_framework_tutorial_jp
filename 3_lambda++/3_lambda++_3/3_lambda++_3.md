# 事前に定義した意味論を再利用すること

[元口座動画 [3'21"]](http://youtu.be/tW4KRdgBIGo)

このレッスンで、既に定義した意味論を何も変えずに再利用する作業を見ていきます。

LAMBDA++は第一章で定義したLAMBDAに比べたら全く違うという気がするかもしれないが、実は再利可能な部分がいろいろあります。例えば、第一章のレッスン7の定義を`syntax Val ::= Int | Bool`から終了までの意味論を現在の定義にコピペーストしましょう。

出来たら、`kompile`して、第一章のLAMBDAと共に提供されたプログラムを実行してみて下さい。それらを全部問題なく実行出来るはずですが、`store`にガーベジがたくさん積もってしまいますね。ガーベジがこんなに残ってることは、再帰をフィックスポイントコンビネータとして定義したことのせいでの現象です。ガーベジコレクションは興味深い課題ですけど、今回は実装しません。その代わりに、よりメモリを効率的に使用する環境を元とするフィックスポイントの定義を調べます。

この再利用作業を見たら、よく浮かんでいる質問は「すでに定義されている言語の部分を再利可能な事情はどう識別出来るの」ってことですね。あいにく、識別する方法は存在していません。次のレッスンに、再利用が静的に発見出来ないように意味論をむちゃくちゃにしちゃうわけを見ていきます。
