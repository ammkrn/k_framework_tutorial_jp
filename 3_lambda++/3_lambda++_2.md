# 意味論的計算アイテム

[元講座動画 [8'02"]](http://youtu.be/BYhQQW6swfc)

このレッスンで、「置換」じゃなくて、「環境」に基づくLAMBDA++言語を定義します。「計算」を表す`K`という構文カテゴリにアイテムを追加することの簡潔さも見ていきます。

基本的に言うなら、環境を元とする言語の中心的な概念は２つのマッピングを保持すること：変数名から「位置」までの*store(蓄積)*マッピングと「位置」から値までの*環境*マッピングです。表現を評価している時に、変数の値を検索するために環境でその変数の位置を参照し、見つけた位置が蓄えている値を検索するっていう仕事になります。LAMBDA++はかなり簡単な言語ですので、グローバル環境を一つ作ればいいんです。IMPと同様に、全セルを`<T>`セルの中に入れていきます。

```
    configuration <T>
                    <k> $PGM:Exp </k>
                    <env> .Map </env>
                    <store> .Map </store>
                  </T>
```

\***********************

翻訳者ノート:

1. 「環境」と「蓄積」はそれぞれ英語で「environment」と「store」と言われるので、<env>と<store>で書かれます。

2. このレッスンでよく見るRhoという物はｋのビルトインMap型としてある物です。Rho[x <- 1]は「Rho中の鍵・値マッピングを与えられた値でアプデートして」という意味の記号法です。これから分からない記号があったら、`k/k-distribution/include/builtin`のどこかに定義されるはずので、grepとかで検索すれば見つけられると思います。例えばここに使用されているビルトインMapの構文や記号は`k/k-distribution/include/builtin/domains.k`に定義されています。

3. 上記の環境・蓄積の説明がちょっと不思議に聞こえるなら、「仮想メモリ」と同じような物として考えられます。

```
// この例で`N`はメモリにある位置を表し、18は普段のInt、宣言したい束縛は x = 18 だ;

<env>   x |-> N   </env>
<store> N |-> 18 </store>
```

```
// こういうのはｋで有効な書き方ではないけどね

      x     18
 env   \   /   store
         N
```

というような関係になります。従って、このような束縛ならxの値を検索する仕事が任された時、手続きは`<env>`から `x` のメモリ位置を検索して `N` を見つけるから、`<store>` に `N` というメモリ位置は何を保持しているかってことを検索することです。

\***********************

改めて、`$PGM`はパースされたプログラムが置かれた場所を表します。現在の定義と従って、プログラムの環境も蓄積も何も入っていないように初期化されます。

環境元のラムダ計算式なら、ラムダ関数は*クロージャ・closures*に評価されます。

```
    rule <k> lambda X:Id . E => closure(Rho,X,E) ...</k>
	     <env> Rho </env>
```

closureはラムダ関数と似たような物ですが、ラムダ関数と違って、closureは宣言時の環境も保持しています。で、クロージャが評価されたら、体にある変数が蓄積のどこに位置していることが分かります。それで、ラムダ関数と識別子はそれぞれクロージャ、蓄積にある値まで評価するので、`Val`ではなくなりました。


クロージャを評価する手続きは：
1. クロージャの環境を切り替える (現在の環境をクロージャにある閑居として書き直す)
2. クロージャに渡されている引数と対応する束縛を環境の中に作る
3. クロージャの体を評価する
4. 元の環境を復旧する

これらのことは一つだけの規則で定義出来ます。

```
    rule <k> closure(Rho,X,E) V:Val => E ~> Rho' ...</k>
         <env> Rho' => Rho[X <- !N] </env>
         <store>... .Map => (!N:Int |-> V) ...</store>
```

翻訳者ノート： この規則がわからねければ、補助ノートがこのレッスンのしたに書かれています。

この規則は以下のことを一度で原子的にやります:
+ クロージャを「体の中身としてある表現 ~> 環境を復旧する演算」という連続に変化する
+ `!N`構文で、新たな蓄積にある位置を発生させる(この構文は以下に説明されます)
+ 環境に`X`識別子を`!N`と束縛する
+ 蓄積内、`!N`の位置に`V`をおいておく

あと、`k`セルにおいて置かれた`Rho'`環境を`<env>`セルに復旧する規則：

```
 rule <k> _:Val ~> (Rho => .) ...</k> 
      <env> _ => Rho </env>

```

「環境復旧タスクを表す`Rho`の前にある要素が「値・結果」まで評価された時点で、現在の環境を`Rho`と切り替えて、`Rho`を計算から溶けていって」意味論のある規則です。

これらの規則は確かにここまで見たk規則の中から最も複雑なやつらですね。特にクロージャを評価する規則はかなり火力ある物ですが、あまり長たらしくない。中にある演算は全部必要不可欠で、その立場から見たら効率的でもあります。古典的な書き直し規則がその代わりに用いられたら、残っている蓄積も明示的に処理することが必要です。ｋなら、使用しないことは`...`で省略可能です。

では、規則に使用された感嘆符付きのことを調べましょう。感嘆符付きの文字、例えば`!N: X` の意味は「この規則が召喚されるたび、どこにも使用されたことがない任意の`!N`で参照出来る`X`ソート真新しい要素」ということを表します。感嘆符付き文字は規則の右側だけで使用可能です。この構文から発生する要素の新しさが保証されていますが、その要素の本当の値がｋのバージョンなどのことと一緒に変わるかもしれないので、値に頼らないで下さい。

前回の置換に基づく定義と違って、今回は検索規則が必要です:

```
    rule <k> X => V ...</k>
         <env>... X |-> N ...</env>
         <store>... N |-> V ...</store>
```

「`X`識別子が`<k>`セルの最上要素になったら、`X`と対応する`N`と呼ぶ`env`位置を参考して、`store`の`N`位置に保持されている`V`値を`X`と交換して下さい」という意味論がある規則です。


ラムダを評価する規則やこの環境を復旧する規則は遷移にしたくないので、`kompile`する前に、それらを`strucutral`にしましょう。

`kompile`しましょう...で、失敗になっちゃおう

返ってきたエラーは`V:Val`をクロージャを評価する規則に入れられないことを言っていますね。なぜならば、`Val`と`Exp`は現在、全然つ繋がっていないんだから、文句になったことは、「valになった項は`val`対適用出来ない」ってことです。関数適用は値ではなく、表現対定義されているんです。今回、`Val`は`Exp`の元としてもあるということを忘れてしまいました。

```
syntax Exp ::= Val
```

出来たら、少し思案しましょう。

今回、一つのモジュールとしてある定義に「クロージャ」やいろんな補助構文構造を加えましたね。このような一つのまとまりとして書いてある定義はkが読めるけど、他のパーサーは却下するはずです。言語をコンパイルする時に(例えば`lang.k`という言語)、ｋツールズは最初にパーサーの素材を探すので、構文を保持している`-SYNTAX`接尾辞のモジュール(この例で`LANG-SYNTAX`)を探していきます。見つかったら、パーサーがそれから作られるので言語の構文は
全部`-SYNTAX`モジュールに書いてあることが必須。別の構文入りモジュールを見つけられなかったら、`LANG`だけ名乗ってるモジュールを探していきます。望みの行動はそれ以外のことなら、`kompile --help`の出力で代わりの行動を指定する方法を読めます。

第一章のLAMBDAと共に提供されたプログラムを`krun`で実行してみて下さい。`closed-variable-capture.lambda`なら、クロージャが`<k>`セルも`<store>`にも値として存在していますね。ここまでのLAMBDA++で変数が値ではないので、自由変数を持っている表現は変数が引っかかっているようになります。例えば、`free-variable-capture.lambda`にある`z`は評価出来なくて自由であるので詰まっているようになってしまします。`omega.lambda`は今までも正しく繰り返すはずです。

次のレッスンで、LAMBDA++の意味論をもう少し調べていきます。


<hr/>

翻訳者ノート続き：

クロージャの評価を定義する規則の理解する鍵を手に入れるため、例示を見ましょう。Lambda++ にはこのような束縛がないんですけど、こっちの方がわかりやすいと思います。
```
<k> (λ y . (x + y)) ... </k>
<env> [x |-> N] </env>
<store> ... N |-> 10 ... </env>
```
つまり、環境がひとつだけの変数束縛を保持していて`x = 10`で、その束縛は`N`という位置にあります。プログラムに、次の計算は｀(λ y . (x + y))`というラムダ関数だ。

最初なのは、ラムダ関数をclosureに変化する規則が一致します。
```
// Rho は [X |-> N]だ

<k> (λ y . (x + y)) => closure(Rho, y, (x + y)) ... </k>
```

次に、<k>セルにclosureを評価する規則が一致しますね。

```
// Lambda++ で、9・整数は許されている Val ソートの要素ではないけど、こっちのほうがわかりやすいと思う。

<k> closure(Rho, y, (x + y)) 9 => (x + y) ~> [X |-> N] </k>
<env> Rho' => Rho [y |-> !N] </env>
<store> ... .Map => (!N |-> 9) </store>
```

それで、kセルの新しい最上計算は `(x + y)`だけだ。Lambda++ の意味論の通り、検索規則が適用されて、xとyの値は蓄積から読まれて、(10 + 9)になりますね。で、`<k> 9 ~> Rho' </k>`になったら、環境復旧規則が一致して、`<env>`セルが元に戻されます。

楽勝じゃん