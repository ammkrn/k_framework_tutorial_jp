# 考えずに再利用しないで下さい！

[元講座動画 [3'37"]](http://youtu.be/OXvtklaSaSQ)


言語フィーチャの意味論を再利用すればいいかどうかを決める時、フィーチャーの構文だけを踏まえて決めることが魅力的なオプションだそうですが、それは実際に危ない癖になってしまいます。

いかの実験は失敗になりますちゃんとが学習出来るために、レッスン1からの`callcc`の定義を再利用してみましょう。

```
    syntax Exp ::= "callcc" Exp  [strict]
    syntax Val ::= cc(K)
    rule <k> (callcc V:Val => V cc(K)) ~> K </k>
    rule <k> cc(K) V ~> _ =>  V ~> K </k>
```

加えた後の言語定義はレッスン一のプログラムを全部問題なく実行できるので、問題がなさそうですね。しかし、`cc(K)`は、召喚された時に復旧する環境を持つべきです。このバグを見やすくするため、`callcc-env1.lambda`を見ましょう。

```
    let x = 1 in
      ((callcc lambda k . (let x = 2 in (k x))) + x)
```

この表現に、`+`の第二引数としてある`x`はトップレベルの`1`の`x`と束縛されるはずです。けど、`callcc`は環境を復旧していないんだから、その`x`は`callcc`の内なる環境で誤って検索されて、結果は`4`になってしまうはずだ。しかし、デフォールトのocamlバックエンドでコンパイルしたら、正しく`3`になります...なんで？

`+`って正格評価を使うけど、引数が評価される順序は指定されていません。今回、ｋは右側にある`1`を最初に評価して、あとで`callcc`の文を評価していますが、`cc`の`K`値は`x`の代わりに`1`を受け取っています...第四章で、プログラムの非決定的な行動を全部同時に露出する方法を見ますが、今回はちゃんと古典的に検査していきましょう。

「問題となる所は`+`の非決定的な評価順序だから、それを明示的に指定すれば解決出来る」と思っている方々が多くいると思うかもしれないので、それを試してみましょう。決定的な評価順序を指定する方法が２つあります。

1. 意味論に、`+`を`seqstrict`にする。そうすると、強制される順序は左から右へ。

こうすれば、確かに`4`まで評価しますが、もっと深く掘り下げていけば、このやり方はこの特定の事情の問題しか解決しません。

2. `callcc-env2.lambda`と同様、古典的に`let`束縛子を使って左から右への順序を広域的に強制する。

```
    let x = 1 in
      let a = callcc lambda k . (let x = 2 in (k x)) in
        let b = x in
	      (a + b)
```

しかし、これも正しくありません。kツールの`--search`フィーチャーを使ってプログラムの全行動を検索すれば、今までも`3`も`4`になる可能性あります。それより、`+`が`seqstrict`にされたら、`3`になる行動,`4`になる行動が両方残ってしまいます。いかにして...実は、問題となるところは関数適用する構文の非決定性です。`let-in`構造の意味論は普通のラムダ関数になるってことを思い出しなさい:

```
    rule let X = E in E' => (lambda X . E') E     [macro]
```

だから、上記のプログラムは`x`が`1`と束縛されている環境を持ちながら、以下のようになります。

```
    (lambda a . ((lambda b . a + b) x)) (callcc lambda k . (let x = 2 in (k x)))
```

左にある表現が最初に評価されたら、結果は`x`が`1`と束縛されている環境が存在しているクロージャになるので、`callcc`の引数にある`x`対適用された時点で、`x`がちゃんと検索されて、最終的に`3`になります。一方、右にある表現が最初に評価されたら、`cc`の値は左にある表現をそのままフリーズして、そこにある`x`と現時点の`x <-1`を持っている環境との関係を切って、表現全体`4`として評価します。


この話の教訓は、考えずに再利用しないで下さい!

次のレッスンで、`callcc`の環境元意味論を修正するため、`cc`と再帰を環境に基づく意味論を定義していきます。

