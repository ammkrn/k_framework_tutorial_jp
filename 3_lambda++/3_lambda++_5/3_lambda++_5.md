# 意味論的計算アイテム続き

[元講座動画 [5'19"]](http://youtu.be/dP3FW0kZN6k)

今回も、意味論的な計算アイテムの調べを続いて、便利となるポイントを集中していきます。詳しく言ったら、`callcc`の環境に基づく定義を修正して、再帰計算を表す`mu`も環境元の構造にします。

最初に、`callcc`を調整していきましょう。レッスン4で見た問題となるところは、何かの項が現時点の続き計算(current continuation)へ渡されたら、復旧された物は計算だけですが、環境も復旧することが必要です。これは簡単に修理できる問題です:

1. `cc`を計算だけではなく、環境も受ける物に変更する
2. 意味論規則を環境のスナップショットを撮って、`cc`が召喚された時にそのスナップショットを復旧する物にします

```
    syntax Val ::= cc(Map,K)
    rule <k> (callcc V:Val => V cc(Rho,K)) ~> K </k> <env> Rho </env>
    rule <k> cc(Rho,K) V:Val ~> _ =>  V ~> K </k> <env> _ => Rho </env>
```

出来たら、`kompile`して`callcc-env2.lambda`が正しく`3`に評価されることを確認しましょう。新たに作った`<k/>`セルにある計算として使用可能な`cc`値はclosureと同様にかなり意味論っぽくある物ものです。

`mu`と対応するclosureと似たような意味論的なアイテムをもう一つ加えていきましょう。第1章のLAMBDAと同じく、`letrec`を`mu`になるものとして定義していきます。今回のLAMBDA++は置換に頼らないので`mu`の`binder`注記を削除できます。

```
    syntax Exp ::= "letrec" Id Id "=" Exp "in" Exp
                 | "mu" Id "." Exp      [latex(\mu{#1}.{#2})]
    rule letrec F:Id X = E in E' => let F = mu F . lambda X . E in E'    [macro]
```

`<store>`にある位置を`mu X . E`が使用するほど確保するため、`mu`の表現を特別なクロージャと切り替えていこう。この特別なクロージャは`X`をクロージャ全体の表現と束縛します。

```
    syntax Exp ::= muclosure(Map,Exp)
    
    rule <k> mu X . E => muclosure(Rho[X <- !N], E) ...</k>
         <env> Rho </env>
         <store>... .Map => (!N:Int |-> muclosure(Rho[X <- !N], E)) ...</store>
      [structural]
```

評価中に、`mu X . E`が現れる度に`E`を評価することが必要となるので、`muclosure`は値としてあるわけがありません。今回、`muclosure`は表現として宣言されますが、計算として宣言してもいいんです。

最後に、`muclosure`を開けて縮小する規則はこれ:

```
  rule <k> muclosure(Rho,E) => E ~> Rho' ...</k>
       <env> Rho' => Rho </env>
```


`Rho`という現在の環境が`E`の実行前保存され、実行後復旧されるべきです。なぜならば、フィックスポイントは`mu X . E`が宣言された所とまったく違う環境がある文脈で召喚される可能性があるから、現在の環境を表す`Rho`は`E`の評価の前に保存され、後え復旧されるべきです。

はい、完成です！もう一回`kompile`して、第1章レッスン7でみた`factorial-letrec.lambda`を実行しましょう。覚えないかもしれませんが、このプログラムを前の昔の言語定義で実行した時、フィックスポイントコンビネータを計算する行動からのガーベジがメモリにいっぱい積もってた。このレッスンで新たに書いた言語定義は再帰表現を計算するために必要となるメモリ確保の量がかなり少なくなりました。

次回、最終レッスンでLAMBDA++をちゃんと終了するためちゃんとドキュメンテーションを書いていきます。

