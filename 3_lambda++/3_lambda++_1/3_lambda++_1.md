## 突然コントロール変更

[元講座動画 [6'28"]](http://youtu.be/UZ9iaus024g)


今回、実行の制御構造を急に変更可能な言語構造を調べるため、第一章で作ったLAMBDA言語に*call-with-current-continuation; 略記 `callcc`*を追加するように、LAMBDA++を新たに作ります。第一章レッスン8の`lambda.k`(コメント抜き版)から始めるので、その定義をコピペして下さい。

`callcc`は最も詳しく制御をコントロールする構造の一つだから、フレームワークの制御構造をコントロール能力を測るためのすぐれた計量です。最初の`callcc`を実装した言語は`scheme`だったんですが、その時からいくつかの言語も`callcc`を含めました。

`callcc`は何するかというと、`e`と`k`はそれぞれ普段関数、計算の残っている文脈を表す関数としましょう。`callcc (e)`は`k`を`e`へ渡して、`e`が何かの項を`k`へ渡すと、現在の実行文脈が捨てられて、`k`がその代わりに使用されます。`e`が何も渡されない場合、普通のように評価されます。

例えば、今回のtestsにある `callcc-jump.lambda`は`15`じゃなくて、`17`になってほしいんです。

```
    (callcc (lambda k . ((k 5) + 2))) + 10
```
この例で、`k`としてある文脈は `[] + 10` です。一方、`callcc-not-jump.lambda`は`17`になって欲しい。

```
    (callcc (lambda k . (5 + 2))) + 10
```

`callcc`はかなり火力ある言語構造としてありますので、別のフレームワークで定義することが難しいですが、kで`callcc`は２つの簡潔な規則で定義出来ます。

```
    syntax Exp ::= "callcc" Exp  [strict]
    syntax Val ::= cc(K)
    rule <k> (callcc V:Val => V cc(K)) ~> K </k>
    rule <k> cc(K) V ~> _ =>  V ~> K </k>
```

最初に、注記付きの構文を調べましょう。`callcc`の引数はまだ関数まで評価されてないかもしれないので、正格評価を使う構造として定義しました。`callcc`と従って、残っている文脈をエンコードして、`callcc`の引数へ渡す必要があります。LAMBDAは「値呼び」言語なので、その文脈を値としてエンコードしないといけません。`Val`にしたくない計算もあるので、計算を`Val`のサブソートにしたくありません。だから、今回は新たな`cc`というどの計算も保持可能な`Val`の元としてある構造を宣言しました。

\#####################################

翻訳者ノート：

私、`callcc`を定義する規則を最初に見た時全然わからなかったですが、実際にあまり難しかない。少しコツとなるところは、kの意味論規則は`=>`で２つの「書き換え前」、「書き換え後」の時に分割されますが、その状態は矢印の範囲を限る丸括弧外及びません。矢印の範囲外のところは変わりません。`callcc-jump.lambda`を見て行きましょう。

最初の規則は `<k> (callcc V:Val => V cc(K)) ~> K </k>`の代わりに、`<k> callcc V:Val ~> K => callcc V cc(K) ~> K ... </k>`というように考えられます。

```
規則 <k> (callcc V:Val => V cc(K)) ~> K </k>
実際 <k> (callcc (λ k . ((k 5) + 2)) => (λ k . ((k 5) + 2)) cc(+10)) ~> (+10) </k>

V := (λ k . ((k 5) + 2))
K := (+10) だが、この例なら (λ x . (x + 10)) というように考えたほうがわかりやすいと思う。
```

書き換えは以下のような物を作ります:

```
<k> (λ k . ((k 5) + 2)) cc(+10)) ~> (+10) </k>
```
それで、cc(10)がラムダの引数として適用されます：
```
<k> (cc(+10) 5) +2 ~> (+10) </k> 
```
(cc(+10) 5) ~> は、二番目の規則にある `cc(K) V ~> _ パターンと一致します。注意したほうがいいところは、`V`パターンと一致している物は `5` となりました。
```
<k> (cc(+10) 5) +2 ~> (+10) => 5 ~> (+10) </k>
      cc(K)  V ~> _         =>  V ~> K
```
になります。最後に、`5 ~> (+10)` は温めルールの意味論の文字通り、普通の関数適用として解釈されます。から、15になります。

\########################################


[SDF](http://www.program-transformation.org/Sdf/)に触発されて、kは`cc`と似たような補助意味論演算をコンパクトに定義する能を提供してくれます。必要な部品は名前、開け丸括弧、「,」区別引数のリスト、閉じ丸括弧だけです。定義したい規則はこのように書けるなら、`cc`の場合でやったように、終端記号を囲むための引用符を省略可能です。

`callcc`の規則には、`<k>`セルを全部一致していたってことを確かめるため、`<k>`セルを明示的に書くことが必要になりました。セルの境界を書いていかないと、以下のような規則になりますね：　

```
    rule (callcc V:Val => V cc(K)) ~> K
    rule cc(K) V ~> _ =>  V ~> K
```

そのような`callcc`なら、残っている計算の接頭語を非決定的に渡して、そのかけらを引数へ渡す物になります。そのような規則を含む言語を使ってプログラムを書いてみたいか？


いくつかのよく見る制御構造を変更するコンストラクトは`callcc`を使って実装出来ます。`callcc-return.lambda`は`return`文のような行動を手に入れる手続きを実演します。

```
    letrec f x = callcc (lambda return . (
      f (if (x <= 0) then ((return 1) / 0) else 2)
    ))
    in (f -3)
```

この例での`f`再帰呼出しとゼロ割が無視されて、`1` になるはずです。注意したほうがいいところは、この例での`return`は変数を表す識別子だけであります。



kで、そのように単一の`<k/>`セルの内容を変更することでプログラムの制御構造を変更出来ます。それは明示的な文脈モデルを持っているフレームワークの長所の一つです。SOSなどのフレームワークは実行文脈を暗黙的に変更しづらい証明文脈として保持するので、`callcc`のような概念を定義することはかなり難しくて、出来栄えはあまり優雅ではありません。

コンフィギュレーション中のセルとのやり取りが分かっているようになったので、次回はLAMBDAをまったく別のアングルから見て、「置換」の複雑さを避けられる本物の関数プログラミング言語の真髄を前より近く追いつく「環境」に基づく定義を書いてみます。


